#+title: Main

This document describes the VariaMos Semantic Translator.
It is an interactive notebook written in Org-Mode with python literate programming features.
It is similar to but more powerful than Jupyter notebooks since it is fully customizable and it provides a superior code editing experience.

* Introduction
The purpose of this software is to take in VariaMos-formatted JSON with a model
of some type, and, using a set of transformation rules:
(a) generate a machine-interpretable represenation of the model;
(b) execute the model in the chosen langugage;
(c) and, return any diagnostic info to VariaMos.

We now turn to defining where we will find our files for processing:

#+begin_src python :session s1 :results none :tangle no
FILE = "/Users/ccr185/workspace/semantic_translator/json/vmosfm.json"
SG = "/Users/ccr185/workspace/semantic_translator/sam/correct_model.json"
SB = "/Users/ccr185/workspace/semantic_translator/sam/wrong_model.json"
RULES = "/Users/ccr185/workspace/semantic_translator/json/fmrules.json"
#+end_src

#+RESULTS:

* Function for transforming the templates
Now that we have our imports and files, we shall create a set of functions that will perform the transformation of a given constraint template into the necessary text:

#+begin_src python :session s1 :results none :tangle yes
import json
import re
from minizinc import Instance, Model, Solver

def replaceWithPattern(pattern, string, occ, v):
    if type(v) is not str and string is not None:
        # print(v.items())
        # print(string)
        [string := string.replace(occ, str(val)) for (k, val) in v.items()]
        # print('OK')
        return string

def replaceExprs(bundle, elems, rels, cons, params, complexT):
    """
    This function replaces the first and second expressions for a bundle's constraint.
    """
    f = [
        iden
        for (k, r) in rels.items()
        for ((iden,_), _) in elems.items()
        if (
            str(r["sourceId"]) == str(iden) and
            str(r["targetId"]) == str(bundle["id"])
        )
    ]
    # replace constraint for principal param
    fs = [
        iden
        for ((iden, _), elem)
        in elems.items()
        if (
            [
                rel
                for (_,rel) in rels.items()
                if rel["sourceId"] == bundle["id"] and
                    rel["targetId"] == iden
            ]
        )
    ]
    fs = ["uuid_" + ef.replace("-","_") for ef in fs if (ef not in f)]
    # print(fs)
    # print(bundle)
    pattern = {
        "F": f[0],
        "Xs": {
            "sum":" + ".join(fs),
            "len": str(len(fs))
        }
    }
    cons = str(cons).replace(
        params[0],
        "uuid_" + pattern[params[0]].replace("-","_")
    )
    funs = r"(" + r"|".join(complexT["functions"]) + r")"
    regex_paren = funs + r"\(" + re.escape(params[1]) + r"\)"
    occs = set([
        oc.group(0)
        for oc in re.finditer(regex_paren, cons)
    ])
    [
        cons := cons.replace(
            occ,
            pattern[params[1]][
                re.compile(regex_paren).search(occ).group(1)
            ]
        )
        for occ in occs
    ]
    print(bundle["properties"][1]["type"])
    # handle special range case.
    if bundle["properties"][1]["value"] == "Range":
        ranges = {
         "min": bundle["properties"][2]["value"],
         "max": bundle["properties"][3]["value"]
        }
        [cons := cons.replace(params[i], ranges[params[i]]) for i in range(2,len(params))]
    return cons



def bundleCons(bundle, elems, rels, rules):
    """
    This is an auxiliary function that builds the request to replaceExprs
    """
    # get constraint rule
    rule = rules["elementTranslationRules"][0]["Bundle"]
    cons = rule["constraint"][bundle["properties"][1]["value"]]
    complexTrans = rules["complexElemTranslations"]
    return replaceExprs(bundle, elems, rels, cons, rule["param"], complexTrans)


def mapBundles(elems, rels, rules):
    """
    This function collects all the strings related to the bundles
    (it is the only portion of this module that is custom to feature models)
    """
    return [
        bundleCons(bs, elems, rels, rules)
        for bs in [
            e if e["type"] == "Bundle" else None for ((iden, typ), e) in elems.items()
        ]
        if bs is not None
    ]


def mapVar(element, rule):
    """Maps an element into a constraint according to the rules"""
    # return rule
    if bool(rule):
        constraint = (
            rule["constraint"].replace(
                rule["param"], str(element["id"]).replace("-", "_")
            )
            + f'% {element["type"]} -> {element["id"]}'
        )
        return constraint
    # If not bool(rule) then return None


def mapVars(elems, rules):
    """This function collects all strings related to a set of elements and translation rules"""
    return [
        cs
        for cs in [
            mapVar(element, rules["elementTranslationRules"][0][typ])
            if (typ in rules["elementTypes"])
            else None
            for ((ident, typ), element) in elems.items()
        ]
        if cs is not None
    ]


def mapCons(relation, rule):
    """This function maps a relation into a constraint according to the rules"""
    if bool(rule):
        acc = rule["constraint"]
        [
            acc := acc.replace(
                p,
                str(
                    relation[("source" if p == rule["params"][0] else "target") + "Id"]
                ).replace("-", "_"),
            )
            for p in rule["params"]
        ]
        return acc


def mapRels(relations, rules):
    """This function collects all strings related to a set of relations and translation rules"""
    return [
        rs
        for rs in [
            mapCons(
                v, rules["relationTranslationRules"][0][v["properties"][0]["value"]]
            )
            for (k, v) in [
                (k, rel) for (k, rel) in relations.items() if rel["properties"]
            ]
            if (v["properties"][0]["value"] in rules["relationTypes"])
        ]
        if rs is not None
    ]
#+end_src

Next we need to construct our result; we define therefore a function that takes in the
model and the rule file and both generates the constraints and gets a solution from the solver:

#+begin_src python :session s1 :results none :exports none :tangle yes
def run(model, rules, language):
    """This function takes in a model, a set of rules and a language to translate to and runs the procedure"""
    # Get the feature model @ /productLines[0]/domainEngineering/models[0]
    fm = model["productLines"][0]["domainEngineering"]["models"][0]
    # Get the elements
    elementsMap = {(e["id"], e["type"]): e for e in fm["elements"]}
    # Get the relationships
    relationsMap = {r["id"]: r for r in fm["relationships"]}
    # Map the constraints for the vars
    constraints = (
        mapVars(elementsMap, rules)
        + mapRels(relationsMap, rules)
        + mapBundles(elementsMap, relationsMap, rules)
        + ["solve satisfy;"]
    )
    # print(constraints)
    print("-----------------------MODEL--------------------------------")
    print("\n".join([c for c in constraints]))
    # Add model and solver
    gecode = Solver.lookup("gecode")
    model = Model()
    model.add_string("\n".join([c for c in constraints]))
    instance = Instance(gecode, model)
    result = instance.solve()
    print("----------------------/MODEL--------------------------------")
    return result
#+end_src

We also define a function that allows us to test things locally before exposing our code to the server.

#+begin_src python :session s1 :results output :exports both :tangle yes
def test():
    """Test function locally"""
    # Load file
    with open(SG, "r") as f:
        # Load json as obj
        model = json.load(f)
        # Create the rules
        with open(RULES, "r") as r:
            rules = json.load(r)
            x = run(model, rules, 'minizinc')
            print("-----------------------RESULTS------------------------------")
            print(x)
            print("----------------------/RESULTS------------------------------")

test()
#+end_src

#+RESULTS:
#+begin_example
String
String
String
String
-----------------------MODEL--------------------------------
var 1..1:'uuid_7a4982f4_2f18_4a39_bf72_1b445c95d74d';% RootFeature -> 7a4982f4-2f18-4a39-bf72-1b445c95d74d
var 0..1:'uuid_fbf7f047_4459_4d5b_84e3_bc5f0e4cde6c';% AbstractFeature -> fbf7f047-4459-4d5b-84e3-bc5f0e4cde6c
var 0..1:'uuid_da16e281_e363_45fb_b32f_0366332f9288';% AbstractFeature -> da16e281-e363-45fb-b32f-0366332f9288
var 0..1:'uuid_5903f5df_e901_416b_bf6e_406658fe446f';% ConcreteFeature -> 5903f5df-e901-416b-bf6e-406658fe446f
var 0..1:'uuid_4e5a3e98_2024_43fc_b41a_4f8d87430a4d';% ConcreteFeature -> 4e5a3e98-2024-43fc-b41a-4f8d87430a4d
var 0..1:'uuid_4fb12fc6_2ac0_44c2_9e1a_ec1bb4bd1515';% ConcreteFeature -> 4fb12fc6-2ac0-44c2-9e1a-ec1bb4bd1515
var 0..1:'uuid_6b7e57a6_4d49_490c_86d1_5f054614b281';% ConcreteFeature -> 6b7e57a6-4d49-490c-86d1-5f054614b281
var 0..1:'uuid_e033aaac_c460_45d1_999a_38b3ebf7bfa4';% ConcreteFeature -> e033aaac-c460-45d1-999a-38b3ebf7bfa4
var 0..1:'uuid_76b1b171_81e0_49d8_836e_38b62a893bbf';% ConcreteFeature -> 76b1b171-81e0-49d8-836e-38b62a893bbf
var 0..1:'uuid_3bf4c5f1_a6b1_4162_902a_8047b8935b38';% ConcreteFeature -> 3bf4c5f1-a6b1-4162-902a-8047b8935b38
var 0..1:'uuid_34ba47c1_4afe_401f_b555_cabc160b7ef3';% ConcreteFeature -> 34ba47c1-4afe-401f-b555-cabc160b7ef3
var 0..1:'uuid_5d274670_6a3d_4e86_bec0_c55333d74c04';% ConcreteFeature -> 5d274670-6a3d-4e86-bec0-c55333d74c04
var 0..1:'uuid_c3c7c42b_223a_48c9_9ab9_0175ccc8550b';% ConcreteFeature -> c3c7c42b-223a-48c9-9ab9-0175ccc8550b
var 0..1:'uuid_57a12aaf_6684_46c2_a85b_2ba01c200cc0';% ConcreteFeature -> 57a12aaf-6684-46c2-a85b-2ba01c200cc0
var 0..1:'uuid_df9eb05a_69ce_4050_b329_d1ce5a7e15ef';% ConcreteFeature -> df9eb05a-69ce-4050-b329-d1ce5a7e15ef
var 0..1:'uuid_b93d709b_1a4a_4898_a8f9_b0207891525a';% ConcreteFeature -> b93d709b-1a4a-4898-a8f9-b0207891525a
constraint :: "7a4982f4_2f18_4a39_bf72_1b445c95d74d mandatory da16e281_e363_45fb_b32f_0366332f9288" (uuid_7a4982f4_2f18_4a39_bf72_1b445c95d74d == uuid_da16e281_e363_45fb_b32f_0366332f9288);
constraint :: "7a4982f4_2f18_4a39_bf72_1b445c95d74d mandatory fbf7f047_4459_4d5b_84e3_bc5f0e4cde6c" (uuid_7a4982f4_2f18_4a39_bf72_1b445c95d74d == uuid_fbf7f047_4459_4d5b_84e3_bc5f0e4cde6c);
constraint :: "5903f5df_e901_416b_bf6e_406658fe446f optional e033aaac_c460_45d1_999a_38b3ebf7bfa4" (uuid_5903f5df_e901_416b_bf6e_406658fe446f >= uuid_e033aaac_c460_45d1_999a_38b3ebf7bfa4);
constraint :: "5903f5df_e901_416b_bf6e_406658fe446f mandatory 76b1b171_81e0_49d8_836e_38b62a893bbf" (uuid_5903f5df_e901_416b_bf6e_406658fe446f == uuid_76b1b171_81e0_49d8_836e_38b62a893bbf);
constraint :: "4fb12fc6_2ac0_44c2_9e1a_ec1bb4bd1515 optional c3c7c42b_223a_48c9_9ab9_0175ccc8550b" (uuid_4fb12fc6_2ac0_44c2_9e1a_ec1bb4bd1515 >= uuid_c3c7c42b_223a_48c9_9ab9_0175ccc8550b);
constraint :: "c3c7c42b_223a_48c9_9ab9_0175ccc8550b excludes 57a12aaf_6684_46c2_a85b_2ba01c200cc0" not (uuid_c3c7c42b_223a_48c9_9ab9_0175ccc8550b == 1 /\ uuid_57a12aaf_6684_46c2_a85b_2ba01c200cc0 == 1);
constraint :: "4fb12fc6_2ac0_44c2_9e1a_ec1bb4bd1515 optional 57a12aaf_6684_46c2_a85b_2ba01c200cc0" (uuid_4fb12fc6_2ac0_44c2_9e1a_ec1bb4bd1515 >= uuid_57a12aaf_6684_46c2_a85b_2ba01c200cc0);
constraint :: "3bf4c5f1_a6b1_4162_902a_8047b8935b38 includes 34ba47c1_4afe_401f_b555_cabc160b7ef3" (uuid_3bf4c5f1_a6b1_4162_902a_8047b8935b38 == 1) -> (uuid_34ba47c1_4afe_401f_b555_cabc160b7ef3 == 1);
constraint :: "uuid_fbf7f047_4459_4d5b_84e3_bc5f0e4cde6c AND Xs" (uuid_fbf7f047_4459_4d5b_84e3_bc5f0e4cde6c == 1) -> (2 == uuid_5903f5df_e901_416b_bf6e_406658fe446f + uuid_4e5a3e98_2024_43fc_b41a_4f8d87430a4d);
constraint :: "uuid_da16e281_e363_45fb_b32f_0366332f9288 OR Xs " (uuid_da16e281_e363_45fb_b32f_0366332f9288 == 1) -> (2 >= uuid_4fb12fc6_2ac0_44c2_9e1a_ec1bb4bd1515 + uuid_6b7e57a6_4d49_490c_86d1_5f054614b281);
constraint :: "group cardinality uuid_4e5a3e98_2024_43fc_b41a_4f8d87430a4ds" (uuid_4e5a3e98_2024_43fc_b41a_4f8d87430a4d == 1) -> ((uuid_4e5a3e98_2024_43fc_b41a_4f8d87430a4d * 1 <= uuid_3bf4c5f1_a6b1_4162_902a_8047b8935b38 + uuid_34ba47c1_4afe_401f_b555_cabc160b7ef3 + uuid_5d274670_6a3d_4e86_bec0_c55333d74c04) /\ (uuid_3bf4c5f1_a6b1_4162_902a_8047b8935b38 + uuid_34ba47c1_4afe_401f_b555_cabc160b7ef3 + uuid_5d274670_6a3d_4e86_bec0_c55333d74c04 <= uuid_4e5a3e98_2024_43fc_b41a_4f8d87430a4d * 3));
constraint :: "uuid_6b7e57a6_4d49_490c_86d1_5f054614b281 XOR Xs" (uuid_6b7e57a6_4d49_490c_86d1_5f054614b281 == 1) -> (uuid_6b7e57a6_4d49_490c_86d1_5f054614b281 == uuid_df9eb05a_69ce_4050_b329_d1ce5a7e15ef + uuid_b93d709b_1a4a_4898_a8f9_b0207891525a);
solve satisfy;
----------------------/MODEL--------------------------------
-----------------------RESULTS------------------------------
Solution(uuid_7a4982f4_2f18_4a39_bf72_1b445c95d74d=1, uuid_fbf7f047_4459_4d5b_84e3_bc5f0e4cde6c=1, uuid_da16e281_e363_45fb_b32f_0366332f9288=1, uuid_5903f5df_e901_416b_bf6e_406658fe446f=1, uuid_4e5a3e98_2024_43fc_b41a_4f8d87430a4d=1, uuid_4fb12fc6_2ac0_44c2_9e1a_ec1bb4bd1515=0, uuid_6b7e57a6_4d49_490c_86d1_5f054614b281=0, uuid_e033aaac_c460_45d1_999a_38b3ebf7bfa4=0, uuid_76b1b171_81e0_49d8_836e_38b62a893bbf=1, uuid_3bf4c5f1_a6b1_4162_902a_8047b8935b38=0, uuid_34ba47c1_4afe_401f_b555_cabc160b7ef3=0, uuid_5d274670_6a3d_4e86_bec0_c55333d74c04=1, uuid_c3c7c42b_223a_48c9_9ab9_0175ccc8550b=0, uuid_57a12aaf_6684_46c2_a85b_2ba01c200cc0=0, uuid_df9eb05a_69ce_4050_b329_d1ce5a7e15ef=0, uuid_b93d709b_1a4a_4898_a8f9_b0207891525a=0, _checker='')
----------------------/RESULTS------------------------------
#+end_example
